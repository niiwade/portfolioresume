'use client'


import * as THREE from "three"
import { Canvas, useFrame } from "@react-three/fiber"
import { ContactShadows, Float, Environment, useGLTF, } from "@react-three/drei"
import { Suspense, useEffect, useRef, useState } from "react"

import { useSpring } from '@react-spring/core'
import { a as three } from '@react-spring/three'
import { a as web } from '@react-spring/web'
import { gsap } from "gsap"

export default function Shapes() {
    // This flag controls open state, alternates between true & false
    const [open, setOpen] = useState(false)
    // We turn this into a spring animation that interpolates between 0 and 1
    const props = useSpring({ open: Number(open) })


    return (
        <div className="row-span-1 row-start-1 -mt-9 aspect-square md:col-span-1 md:col-start-2 md:mt-0">

            {/* <div>
          <web.main  style={{ background: props.open.to([0, 1], ['#f0f0f0', '#d25578']) }}>
                <web.h1 style={{ opacity: props.open.to([0, 1], [1, 0]), transform: props.open.to((o) => `translate3d(-50%,${o * 50 - 100}px,0)`) }}>click</web.h1>
                <Canvas dpr={[1, 2]} camera={{ position: [0, 0, -30], fov: 35 }}>
                    <three.pointLight position={[10, 10, 10]} intensity={1.5} color={props.open.to([0, 1], ['#f0f0f0', '#d25578'])} />
                    <Suspense fallback={null}>
                        <group rotation={[0, Math.PI, 0]} onClick={(e) => (e.stopPropagation(), setOpen(!open))}>
                            <Model open={open} hinge={props.open.to([0, 1], [1.575, -0.425])} />
                        </group>
                        <Environment preset="city" />
                    </Suspense>
                    <ContactShadows position={[0, -4.5, 0]} opacity={0.4} scale={20} blur={1.75} far={4.5} />
                </Canvas>
            </web.main>
          </div> */}
            <Canvas className="z-0" shadows gl={{ antialias: false }} dpr={[1, 1.5]} camera={{
                position: [0, 0, 25],
                fov: 30, near: 1, far: 40
            }}>

                <Suspense fallback={null}>
                    <Geometrics />
                    <ContactShadows position={[0, -3.5, 0]}
                        opacity={0.65}
                        scale={40}
                        blur={1}
                        far={9}
                    />
                    <Environment preset="studio" />
                </Suspense>

            </Canvas>
        </div>
    )
}


// function Model({ open, hinge, ...props }) {
//     const group = useRef()
//     // Load model
//     const { nodes, materials } = useGLTF('/mac-draco.glb')
//     // Take care of cursor state on hover
//     const [hovered, setHovered] = useState(false)
//     useEffect(() => void (document.body.style.cursor = hovered ? 'pointer' : 'auto'), [hovered])
//     // Make it float in the air when it's opened
//     useFrame((state) => {
//         const t = state.clock.getElapsedTime()
//         group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, open ? Math.cos(t / 10) / 10 + 0.25 : 0, 0.1)
//         group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, open ? Math.sin(t / 10) / 4 : 0, 0.1)
//         group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, open ? Math.sin(t / 10) / 10 : 0, 0.1)
//         group.current.position.y = THREE.MathUtils.lerp(group.current.position.y, open ? (-2 + Math.sin(t)) / 3 : -4.3, 0.1)
//     })
//     // The view was auto-generated by: https://github.com/pmndrs/gltfjsx
//     // Events and spring animations were added afterwards
//     return (
//         <group ref={group} {...props} onPointerOver={(e) => (e.stopPropagation(), setHovered(true))} onPointerOut={(e) => setHovered(false)} dispose={null}>
//             <three.group rotation-x={hinge} position={[0, -0.04, 0.41]}>
//                 <group position={[0, 2.96, -0.13]} rotation={[Math.PI / 2, 0, 0]}>
//                     <mesh material={materials.aluminium} geometry={nodes['Cube008'].geometry} />
//                     <mesh material={materials['matte.001']} geometry={nodes['Cube008_1'].geometry} />
//                     <mesh material={materials['screen.001']} geometry={nodes['Cube008_2'].geometry} />
//                 </group>
//             </three.group>
//             <mesh material={materials.keys} geometry={nodes.keyboard.geometry} position={[1.79, 0, 3.45]} />
//             <group position={[0, -0.1, 3.39]}>
//                 <mesh material={materials.aluminium} geometry={nodes['Cube002'].geometry} />
//                 <mesh material={materials.trackpad} geometry={nodes['Cube002_1'].geometry} />
//             </group>
//             <mesh material={materials.touchbar} geometry={nodes.touchbar.geometry} position={[0, -0.03, 1.2]} />
//         </group>
//     )
// }



function Geometrics() {
    const geometrics = [
        {
            position: [0, 0, 0],
            r: 0.3,
            geometry: new THREE.IcosahedronGeometry(3)
        }
    ]

    const materials = [
        // new THREE.MeshNormalMaterial(),
        new THREE.MeshStandardMaterial({
roughness:0,
metalness:1.5,
color:0x2596be
        })
    ]

    return geometrics.map(({ position, r, geometry }) => (
        <Geometry
            key={JSON.stringify(position)}
            position={position.map((p) => p * 2)}
            geometry={geometry}
            materials={materials}
            r={r}
        />

    ))
}

function Geometry({ r, position, geometry, materials }) {
    const meshRef = useRef()
    const [visible, setVisible] = useState(false)

    const startingMaterial = getRandomMaterial()

    function getRandomMaterial() {
        return gsap.utils.random(materials)
    }

    function handleClick(e) {
        const mesh = e.object
        gsap.to(mesh.rotation, {
            x: `+=${gsap.utils.random(0, 2)}`,
            y: `+=${gsap.utils.random(0, 2)}`,
            z: `+=${gsap.utils.random(0, 2)}`,
            duration: 1.3,
            ease: "elastic.out(1,0.3)",
            yoyo: true
        })
        mesh.material = getRandomMaterial()
    }

    const handlePointerOver = () => {
        document.body.style.cursor = "pointer"
    }

    const handlePointerOut = () => {
        document.body.style.cursor = "default"
    }

    useEffect(() =>{
      let ctx=  gsap.context(() =>{
            setVisible(true)
            gsap.from(meshRef.current.scale,{
                x:0,
                y:0,
                z:0,
                duration:1,
                ease: "elastic.out(1,0.3)",
                delay:0.3
            })
        })
        return () => ctx.revert() 
    },[]) 


    return (
        <group position={position} ref={meshRef}>
            <Float speed={5 * r} rotationIntensity={6 * r} floatIntensity={5 * r}>
                <mesh geometry={geometry} onClick={handleClick} onPointerOver={handlePointerOver} onPointerOut={handlePointerOut}
                    visible={visible}
                    material={startingMaterial}
                ></mesh>
            </Float>

        </group>
    )

}